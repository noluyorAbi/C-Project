diff --git a/makefile b/makefile
index c39bebb..0b0b1d2 100644
--- a/makefile
+++ b/makefile
@@ -1,76 +1,97 @@
-# Compiler and Flags
+# Compiler und Flags
 CC = clang
-CFLAGS = -Wall -Werror -Imodules -Imodules/args_parser
+CFLAGS = -Wall -Werror -Imodules -Imodules/args_parser -Imodules/tcp_performConnection
 
-# Directories
+# Verzeichnisse
 BIN_DIR = bin
 BUILD_DIR = build
 SRC_DIR = .
-MODULES_DIR = modules/args_parser
+MODULES_DIR = modules
+LIB_DIR = lib
+TESTS_DIR = tests
 
-# Target name
+# Ziele
 TARGET = $(BIN_DIR)/sysprak-client
+LIBRARY = $(LIB_DIR)/libsysprak.a
 
-# Mock data
+# Mock-Daten
 MOCK_ARGS = -g 1234567890123 -p 1
 
-# Source and object files
-SRC = $(shell find $(SRC_DIR) $(MODULES_DIR) -name '*.c' -o -name '*.h')
-OBJ = $(SRC:%.c=$(BUILD_DIR)/%.o)
+# Quellen und Objektdateien
+LIB_SRC = $(shell find $(MODULES_DIR) -name '*.c')
+LIB_OBJ = $(LIB_SRC:%.c=$(BUILD_DIR)/%.o)
+
+MAIN_SRC = main.c
+MAIN_OBJ = $(BUILD_DIR)/main.o
+
+TEST_SRC = $(shell find $(TESTS_DIR) -type f -name '*.c')
+TEST_OBJ = $(TEST_SRC:%.c=$(BUILD_DIR)/%.o)
+
 CLANG_FORMAT = clang-format
 
-# Default target
+# Standardziel
 .DEFAULT_GOAL := all
 
-# Phony targets
-.PHONY: all run clean format tidy
+# Phony-Ziele
+.PHONY: all run clean format tidy test
+
+# Kompilieren von Bibliotheksobjektdateien
+$(BUILD_DIR)/%.o: %.c
+	@mkdir -p $(dir $@)
+	$(CC) $(CFLAGS) -c $< -o $@
+
+# Kompilieren von main.o mit korrektem Header-Pfad
+$(BUILD_DIR)/main.o: main.c modules/tcp_performConnection/performConnection.h
+	@mkdir -p $(dir $@)
+	$(CC) $(CFLAGS) -c $< -o $@
+
+# Erstellen der statischen Bibliothek
+$(LIBRARY): $(LIB_OBJ)
+	@mkdir -p $(LIB_DIR)
+	ar rcs $@ $^
+
+# Linken des Hauptprogramms mit der Bibliothek
+$(TARGET): $(MAIN_OBJ) $(LIBRARY)
+	@mkdir -p $(BIN_DIR)
+	$(CC) $(CFLAGS) -o $@ $^
 
-# Format the source files
+# Formatieren der Quellcode-Dateien
 format:
-	@echo "\n\033[1;35mReformating source files...\033[0m\n"
+	@echo "\n\033[1;35mFormatiere Quellcode-Dateien...\033[0m\n"
 	@formatted_count=0; \
 	for file in $(shell find $(SRC_DIR) $(MODULES_DIR) -name '*.c' -o -name '*.h'); do \
 		if ! $(CLANG_FORMAT) --dry-run --Werror $$file 2>/dev/null; then \
 			$(CLANG_FORMAT) -i $$file; \
-			echo "\033[1;33m  Reformatted:\033[0m $$file"; \
+			echo "\033[1;33m  Formatiert:\033[0m $$file"; \
 			formatted_count=$$((formatted_count + 1)); \
 		else \
-			echo "\033[1;32m  Already formatted:\033[0m $$file"; \
+			echo "\033[1;32m  Bereits formatiert:\033[0m $$file"; \
 		fi; \
 	done; \
 	echo; \
-	echo "\033[1;36mFormatting complete. Total files reformatted: $$formatted_count.\033[0m"
+	echo "\033[1;36mFormatierung abgeschlossen. Gesamtzahl der formatierten Dateien: $$formatted_count.\033[0m"
 
-# Compile the main program
-all: $(TARGET)
-
-$(TARGET): $(OBJ)
-	@mkdir -p $(BIN_DIR)
-	$(CC) $(CFLAGS) -o $@ $^
-	@clang-format -i $(SRC)
+# Clean-Ziel - entfernt Binärdateien und Build-Dateien
+clean:
+	@echo "Bereinige..."
+	@rm -rf $(BIN_DIR) $(BUILD_DIR) $(LIB_DIR)
 
-# Compile object files
-$(BUILD_DIR)/%.o: %.c
-	@mkdir -p $(dir $@)
-	$(CC) $(CFLAGS) -c $< -o $@
-	@clang-format -i $(SRC)
+# Clang-Tidy-Ziel - Analysiert alle Quellcode-Dateien mit clang-tidy
+tidy:
+	@echo "Führe clang-tidy auf Quellcode-Dateien aus..."
+	@for file in $(LIB_SRC) $(MAIN_SRC); do \
+		echo "Analysiere $$file..."; \
+		clang-tidy -p . $$file || { echo "clang-tidy schlug bei $$file fehl"; exit 1; }; \
+	done
+	@echo "clang-tidy-Analyse erfolgreich abgeschlossen."
 
-# Run the program with mock data
+# Ausführen des Hauptprogramms mit Mock-Daten
 run: $(TARGET)
 	./$(TARGET) $(MOCK_ARGS)
-	@clang-format -i $(SRC)
-
-# Clean target - removes binaries and build files
-clean:
-	@echo "Cleaning up..."
-	@rm -rf $(BIN_DIR) $(BUILD_DIR)
-	@clang-format -i $(SRC)
 
-# Clang-Tidy target - Analyze all source files with clang-tidy
-tidy:
-	@echo "Running clang-tidy on source files..."
-	@for file in $(SRC); do \
-		echo "Analyzing $$file..."; \
-		clang-tidy -p . $$file || { echo "clang-tidy failed on $$file"; exit 1; }; \
-	done
-	@echo "clang-tidy analysis completed successfully."
+# Kompilieren und Ausführen von Tests
+test: $(LIBRARY) $(TEST_OBJ)
+	@mkdir -p $(BIN_DIR)
+	$(CC) $(CFLAGS) -o $(BIN_DIR)/sysprak-client-test $(TEST_OBJ) -L$(LIB_DIR) -lsysprak -lpthread
+	@echo "\n\n"
+	@./$(BIN_DIR)/sysprak-client-test
diff --git a/modules/tcp_performConnection/performConnection.c b/modules/tcp_performConnection/performConnection.c
index 831fa4b..ce10cee 100644
--- a/modules/tcp_performConnection/performConnection.c
+++ b/modules/tcp_performConnection/performConnection.c
@@ -1,3 +1,5 @@
+// performConnection.c
+
 #include "performConnection.h"
 
 #include <stdio.h>
@@ -9,135 +11,162 @@
 #define BUFFER_SIZE 1024
 
 /**
- * @brief Sends a message over the socket.
+ * @brief Sendet eine Nachricht über den Socket.
  *
- * @param sockfd The socket file descriptor.
- * @param message The message to send.
- * @return int 0 on success, -1 on error.
+ * @param sockfd Der Socket-Dateideskriptor.
+ * @param message Die zu sendende Nachricht.
+ * @return int EXIT_SUCCESS bei Erfolg, EXIT_FAILURE bei Fehler.
  */
 int sendMessage(int sockfd, const char *message) {
   if (send(sockfd, message, strlen(message), 0) == -1) {
-    perror("Error sending message");
-    return -1;
+    perror("Fehler beim Senden der Nachricht");
+    return EXIT_FAILURE;
   }
-  printf("Sent: %s", message);
-  return 0;
+  fprintf(stdout, "Gesendet: %s", message);
+  return EXIT_SUCCESS;
 }
 
 /**
- * @brief Receives a message over the socket.
+ * @brief Empfängt eine Nachricht über den Socket.
  *
- * @param sockfd The socket file descriptor.
- * @param buffer The buffer to store the received message.
- * @param buffer_size The size of the buffer.
- * @return int 0 on success, -1 on error.
+ * @param sockfd Der Socket-Dateideskriptor.
+ * @param buffer Der Puffer zum Speichern der empfangenen Nachricht.
+ * @param buffer_size Die Größe des Puffers.
+ * @return int EXIT_SUCCESS bei Erfolg, EXIT_FAILURE bei Fehler.
  */
 int receiveMessage(int sockfd, char *buffer, size_t buffer_size) {
-  int bytes_received = recv(sockfd, buffer, buffer_size - 1, 0);
-  if (bytes_received <= 0) {
-    perror("Error receiving message");
-    return -1;
+  ssize_t bytes_received = recv(sockfd, buffer, buffer_size - 1, 0);
+  if (bytes_received < 0) {
+    perror("Fehler beim Empfangen der Nachricht");
+    return EXIT_FAILURE;
+  } else if (bytes_received == 0) {
+    fprintf(stderr, "Verbindung vom Server geschlossen\n");
+    return EXIT_FAILURE;
   }
   buffer[bytes_received] = '\0';
-  printf("Received: %s", buffer);
-  return 0;
+  fprintf(stdout, "Empfangen: %s", buffer);
+  return EXIT_SUCCESS;
 }
 
 /**
- * @brief Handles the Prolog phase of the protocol.
+ * @brief Führt die Verbindungsprozedur gemäß dem Kommunikationsprotokoll durch.
  *
- * @param sockfd The socket file descriptor.
- * @return int 0 on success, -1 on error.
+ * @param sockfd Der Socket-Dateideskriptor für die TCP-Verbindung.
+ * @return int EXIT_SUCCESS bei Erfolg, EXIT_FAILURE bei Fehler.
  */
 int performConnection(int sockfd) {
   char buffer[BUFFER_SIZE];
 
-  // 1. Receive greeting from server
-  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-    return -1;
+  // 1. Begrüßung vom Server empfangen
+  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
-  // Check for the "+ MNM Gameserver" prefix
+  // Überprüfung des Prefix "+ MNM Gameserver"
   if (strncmp(buffer, "+ MNM Gameserver", 16) != 0) {
-    fprintf(stderr, "Unexpected server response: %s\n", buffer);
-    return -1;
+    fprintf(stderr, "Unerwartete Serverantwort: %s\n", buffer);
+    return EXIT_FAILURE;
   }
 
-  // 2. Send client version
+  // 2. Client-Version senden
   const char *client_version = "VERSION 2.42\n";
-  if (sendMessage(sockfd, client_version) != 0) {
-    return -1;
+  if (sendMessage(sockfd, client_version) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
-  // 3. Receive acknowledgment and Game-ID prompt
-  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-    return -1;
+  // 3. Bestätigung und Game-ID-Aufforderung empfangen
+  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
   if (strncmp(buffer, "+ Client version accepted", 25) != 0) {
-    fprintf(stderr, "Client version not accepted: %s\n", buffer);
-    return -1;
+    fprintf(stderr, "Client-Version nicht akzeptiert: %s\n", buffer);
+    return EXIT_FAILURE;
   }
 
-  // 4. Send Game-ID
-  const char *game_id = "ID my-game-id\n"; // Replace with the actual Game-ID
-  if (sendMessage(sockfd, game_id) != 0) {
-    return -1;
+  // 4. Game-ID senden
+  const char *game_id =
+    "ID my-game-id\n"; // Im Test wird "my-game-id" verwendet
+  if (sendMessage(sockfd, game_id) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
-  // 5. Receive game type
-  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-    return -1;
+  // 5. Spieltyp empfangen
+  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
   if (strncmp(buffer, "+ PLAYING NMMorris", 18) != 0) {
-    fprintf(stderr, "Unexpected game type: %s\n", buffer);
-    return -1;
+    fprintf(stderr, "Unerwarteter Spieltyp: %s\n", buffer);
+    return EXIT_FAILURE;
   }
 
-  // 6. Receive game name
-  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-    return -1;
+  // 6. Spielname empfangen (falls erforderlich)
+  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
-  // 7. Send PLAYER command
+  // 7. PLAYER-Befehl senden (ohne zusätzliche Werte)
   const char *player_command = "PLAYER\n";
-  if (sendMessage(sockfd, player_command) != 0) {
-    return -1;
+  if (sendMessage(sockfd, player_command) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
-  // 8. Receive player assignment
-  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-    return -1;
+  // 8. Spielerzuweisung empfangen
+  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
   if (strncmp(buffer, "+ YOU", 5) != 0) {
-    fprintf(stderr, "Unexpected player assignment: %s\n", buffer);
-    return -1;
+    fprintf(stderr, "Unerwartete Spielerzuweisung: %s\n", buffer);
+    return EXIT_FAILURE;
+  } else {
+    // Verarbeitung der Spielerzuweisung
+    fprintf(stdout, "Zugewiesener Spieler: %s", buffer + 5);
   }
 
-  // 9. Receive total players
-  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-    return -1;
+  // 9. Gesamtanzahl der Spieler empfangen
+  if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+    return EXIT_FAILURE;
   }
 
   if (strncmp(buffer, "+ TOTAL", 7) != 0) {
-    fprintf(stderr, "Unexpected total players: %s\n", buffer);
-    return -1;
+    fprintf(stderr, "Unerwartete Gesamtanzahl der Spieler: %s\n", buffer);
+    return EXIT_FAILURE;
+  } else {
+    int total_players;
+    if (sscanf(buffer, "+ TOTAL %d", &total_players) == 1) {
+      fprintf(stdout, "Gesamtanzahl der Spieler: %d\n", total_players);
+    } else {
+      fprintf(stderr, "Fehler beim Parsen der Gesamtanzahl der Spieler: %s\n",
+              buffer);
+      return EXIT_FAILURE;
+    }
   }
 
-  // 10. Receive details of other players
+  // 10. Details der anderen Spieler empfangen
   while (1) {
-    if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != 0) {
-      return -1;
+    if (receiveMessage(sockfd, buffer, BUFFER_SIZE) != EXIT_SUCCESS) {
+      return EXIT_FAILURE;
     }
     if (strncmp(buffer, "+ ENDPLAYERS", 12) == 0) {
-      break; // End of player list
+      break; // Ende der Spielerliste
+    }
+    // Verarbeitung der Spielerinformationen (z.B. Nummer, Name, Bereitschaft)
+    // Beispiel: "+ PLAYER 1 Uli READY"
+    int player_number;
+    char player_name[50];
+    char readiness[20];
+    if (sscanf(buffer, "+ PLAYER %d %49s %19s", &player_number, player_name,
+               readiness)
+        == 3) {
+      fprintf(stdout, "Spieler %d (%s) ist %s.\n", player_number, player_name,
+              strcmp(readiness, "READY") == 0 ? "bereit" : "nicht bereit");
+    } else {
+      fprintf(stderr, "Unbekannte Spielerinfo: %s\n", buffer);
     }
-    // Process player information (e.g., number, name, readiness)
-    printf("Player info: %s", buffer);
   }
 
-  printf("Prolog phase completed successfully.\n");
-  return 0; // Success
-}
\ No newline at end of file
+  fprintf(stdout, "Prolog-Phase erfolgreich abgeschlossen.\n");
+  return EXIT_SUCCESS; // Erfolg
+}
diff --git a/modules/tcp_performConnection/performConnection.h b/modules/tcp_performConnection/performConnection.h
index 6e73344..39e44ea 100644
--- a/modules/tcp_performConnection/performConnection.h
+++ b/modules/tcp_performConnection/performConnection.h
@@ -1,12 +1,35 @@
+// performConnection.h
+
 #ifndef PERFORMCONNECTION_H
 #define PERFORMCONNECTION_H
 
+#include <stddef.h>
+
+/**
+ * @brief Sendet eine Nachricht über den Socket.
+ *
+ * @param sockfd Der Socket-Dateideskriptor.
+ * @param message Die zu sendende Nachricht.
+ * @return int EXIT_SUCCESS bei Erfolg, EXIT_FAILURE bei Fehler.
+ */
+int sendMessage(int sockfd, const char *message);
+
+/**
+ * @brief Empfängt eine Nachricht über den Socket.
+ *
+ * @param sockfd Der Socket-Dateideskriptor.
+ * @param buffer Der Puffer zum Speichern der empfangenen Nachricht.
+ * @param buffer_size Die Größe des Puffers.
+ * @return int EXIT_SUCCESS bei Erfolg, EXIT_FAILURE bei Fehler.
+ */
+int receiveMessage(int sockfd, char *buffer, size_t buffer_size);
+
 /**
- * @brief Handles the Prolog phase of the communication protocol.
+ * @brief Führt die Verbindungsprozedur gemäß dem Kommunikationsprotokoll durch.
  *
- * @param sockfd The socket file descriptor for the TCP connection.
- * @return int 0 on success, -1 on error.
+ * @param sockfd Der Socket-Dateideskriptor für die TCP-Verbindung.
+ * @return int EXIT_SUCCESS bei Erfolg, EXIT_FAILURE bei Fehler.
  */
 int performConnection(int sockfd);
 
-#endif // PERFORMCONNECTION_H
\ No newline at end of file
+#endif // PERFORMCONNECTION_H
diff --git a/modules/tcp_performConnection/tcp_connection.c b/modules/tcp_performConnection/tcp_connection.c
index ba0af74..78b4c4f 100644
--- a/modules/tcp_performConnection/tcp_connection.c
+++ b/modules/tcp_performConnection/tcp_connection.c
@@ -1,4 +1,4 @@
-#include "performConnection.c"
+#include "performConnection.h"
 
 #include <arpa/inet.h>
 #include <netdb.h>
diff --git a/tests/test_performConnection.c b/tests/test_performConnection.c
deleted file mode 100644
index 532d32e..0000000
--- a/tests/test_performConnection.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "performConnection.h"
-
-#include <arpa/inet.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-int main() {
-  int sockfd;
-
-  // Example: Replace with actual socket creation and connection code
-  printf("This is a test for performConnection.c\n");
-
-  // Call performConnection function
-  if (performConnection(sockfd) != 0) {
-    fprintf(stderr, "performConnection failed.\n");
-    return EXIT_FAILURE;
-  }
-
-  printf("performConnection succeeded.\n");
-  return EXIT_SUCCESS;
-}
\ No newline at end of file
